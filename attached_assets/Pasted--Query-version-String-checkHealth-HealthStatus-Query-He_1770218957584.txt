
Query
version
String
checkHealth
HealthStatus!
Query Health Checker module for the status of OAP server
score
Int!
0 means healthy, more than 0 means unhealthy and less than 0 means oap doesn't startup.
details
String
some details about the score value.
getAllServices
[Service!]!
Normal service related meta info
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
group
String
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
searchServices
[Service!]!
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
keyword
String!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
searchService
Service
serviceCode
String!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
getAllBrowserServices
[Service!]!
Fetch all services of Browser type
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
searchBrowserServices
[Service!]!
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
keyword
String!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
searchBrowserService
Service
serviceCode
String!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
getServiceInstances
[ServiceInstance!]!
Service instance query
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
serviceId
ID!
Arg
id
ID!
name
String!
attributes
[Attribute!]!
name
String!
value
String!
language
Language!
instanceUUID
String!
searchEndpoint
[Endpoint!]!
Endpoint query Consider there are huge numbers of endpoint, must use endpoint owner's service id, keyword and limit filter to do query.
keyword
String!
Arg
serviceId
ID!
Arg
limit
Int!
Arg
id
ID!
name
String!
getAllDatabases
[Database!]!
Database related meta info.
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
id
ID!
name
String!
type
String!
getGlobalTopology
Topology
Query the global topology When layer is specified, the topology of this layer would be queried
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
layer
String
Arg
nodes
[Node!]!
id
ID!
The service ID of the node.
name
String!
The literal name of the #id.
type
String
The type name may be 1. The service provider/middleware tech, such as: Tomcat, SpringMVC 2. Conjectural Service, e.g. MySQL, Redis, Kafka
isReal
Boolean!
It is a conjecture node or real node, to represent a service or endpoint.
layers
[String!]!
The layers of the service.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
getServiceTopology
Topology
Query the topology, based on the given service
serviceId
ID!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[Node!]!
id
ID!
The service ID of the node.
name
String!
The literal name of the #id.
type
String
The type name may be 1. The service provider/middleware tech, such as: Tomcat, SpringMVC 2. Conjectural Service, e.g. MySQL, Redis, Kafka
isReal
Boolean!
It is a conjecture node or real node, to represent a service or endpoint.
layers
[String!]!
The layers of the service.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
getServicesTopology
Topology
Query the topology, based on the given services. `#getServiceTopology` could be replaced by this.
serviceIds
[ID!]!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[Node!]!
id
ID!
The service ID of the node.
name
String!
The literal name of the #id.
type
String
The type name may be 1. The service provider/middleware tech, such as: Tomcat, SpringMVC 2. Conjectural Service, e.g. MySQL, Redis, Kafka
isReal
Boolean!
It is a conjecture node or real node, to represent a service or endpoint.
layers
[String!]!
The layers of the service.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
getServiceInstanceTopology
ServiceInstanceTopology
Query the instance topology, based on the given clientServiceId and serverServiceId
clientServiceId
ID!
Arg
serverServiceId
ID!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[ServiceInstanceNode!]!
id
ID!
The instance id of each node,
name
String!
The literal name of the #id. Instance Name.
serviceId
ID!
Service id
serviceName
String!
The literal name of the #serviceId.
type
String
[Deprecated] No type for service instance topology.
isReal
Boolean!
It is a conjecture node or real node, to represent an instance.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
getEndpointTopology
Topology
Query the topology, based on the given endpoint
endpointId
ID!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[Node!]!
id
ID!
The service ID of the node.
name
String!
The literal name of the #id.
type
String
The type name may be 1. The service provider/middleware tech, such as: Tomcat, SpringMVC 2. Conjectural Service, e.g. MySQL, Redis, Kafka
isReal
Boolean!
It is a conjecture node or real node, to represent a service or endpoint.
layers
[String!]!
The layers of the service.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
getEndpointDependencies
EndpointTopology
v2 of getEndpointTopology
endpointId
ID!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[EndpointNode!]!
id
ID!
The instance id of each node,
name
String!
The literal name of the #id. Endpoint Name
serviceId
ID!
Service id
serviceName
String!
The literal name of the #serviceId.
type
String
[Deprecated] No type for service instance topology.
isReal
Boolean!
It is a conjuecture node or real node, to represent an instance.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
getProcessTopology
ProcessTopology
Query the topology, based on the given instance
serviceInstanceId
ID!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[ProcessNode!]!
id
ID!
The process id of each node.
serviceId
ID!
Service id
serviceName
String!
The literal name of the #serviceId.
serviceInstanceId
ID!
Service Instance id
serviceInstanceName
String!
The literal name of the #serviceInstanceId.
name
String!
The name of the process
isReal
Boolean!
It's a virtual node or real node. A unreal node means that the current node is not a process belonging to this instance, but interacting with the processes belonging to the instance.
calls
[Call!]!
source
ID!
sourceComponents
[ID!]!
The protocol and tech stack used at source side in this distributed call No value in instance topology and endpoint dependency.
target
ID!
targetComponents
[ID!]!
The protocol and tech stack used at target side in this distributed call No value in instance topology and endpoint dependency.
id
ID!
detectPoints
[DetectPoint!]!
The detect Points of this distributed call.
typeOfMetrics
MetricsType!
Metrics definition metadata query. Response the metrics type which determines the suitable query methods.
name
String!
Arg
listMetrics
[MetricDefinition!]!
Get the list of all available metrics in the current OAP server. Param, regex, could be used to filter the metrics by name.
regex
String
Arg
name
String!
type
MetricsType!
catalog
String
Catalog includes SERVICE_CATALOG,SERVICE_INSTANCE_CATALOG,ENDPOINT_CATALOG, SERVICE_RELATION_CATALOG,SERVICE_INSTANCE_RELATION_CATALOG_NAME,ENDPOINT_RELATION_CATALOG_NAME
execExpression
ExpressionResult!
expression
String!
Arg
entity
Entity!
Arg
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
type
ExpressionResultType!
results
[MQEValues!]!
When the type == TIME_SERIES_VALUES or SINGLE_VALUE, the results would be a collection of MQEValues according to the metric labels. In other legal type cases, only one MQEValues is expected in the array.
metric
Metadata!
The metadata description of this value series.
labels
[KeyValue!]!
Key-value pairs to describe the metric
key
String!
value
String
values
[MQEValue!]!
1. When the type == SINGLE_VALUE, values only have one value. 2. When the type == TIME_SERIES_VALUES, values would match the given elements in the duration range. 3. When the type == SORTED_LIST, values could be results of `sort(metric)` 4. When the type == RECORD_LIST, values could be sampled records
id
ID
Timestamp or name of the entity or record. It could be NULL if it is the result of an aggregate calculation.
value
String
Value is formatted double/int or NULL if the value is absent.
traceID
ID
Sampled record could associate with a trace. This would be a trace ID only.
error
String
When type == ExpressionResultType.UNKNOWN, the error message includes the expression resolving errors.
getValues
IntValues
metric
BatchMetricConditions!
Arg
name
String!
Arg
Metric name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
ids
[ID!]!
Arg
Id in this metric type. In the above case, the id should be endpoint id.
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
values
[KVInt!]!
id
ID!
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
Since 9.5.0, isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
getLinearIntValues
IntValues
metric
MetricCondition!
Arg
name
String!
Arg
Metric name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
id
ID
Arg
Id in this metric type. In the above case, the id should be endpoint id.
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
values
[KVInt!]!
id
ID!
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
Since 9.5.0, isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
getMultipleLinearIntValues
[IntValues!]!
Query the type of metrics including multiple values, and format them as multiple linears. The seq of these multiple lines base on the calculation func in OAL Such as, should us this to query the result of func percentile(50,75,90,95,99) in OAL, then five lines will be responded, p50 is the first element of return value.
metric
MetricCondition!
Arg
name
String!
Arg
Metric name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
id
ID
Arg
Id in this metric type. In the above case, the id should be endpoint id.
numOfLinear
Int!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
values
[KVInt!]!
id
ID!
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
Since 9.5.0, isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
getSubsetOfMultipleLinearIntValues
[IntValues!]!
metric
MetricCondition!
Arg
name
String!
Arg
Metric name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
id
ID
Arg
Id in this metric type. In the above case, the id should be endpoint id.
linearIndex
[Int!]!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
values
[KVInt!]!
id
ID!
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
Since 9.5.0, isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
getThermodynamic
Thermodynamic
metric
MetricCondition!
Arg
name
String!
Arg
Metric name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
id
ID
Arg
Id in this metric type. In the above case, the id should be endpoint id.
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
nodes
[[Int]!]!
Each element in nodes represents a point in Thermodynamic Diagram And the element includes three values: 1) Time Bucket based on query duration 2) Response time index. Response time = [responseTimeStep * index, responseTimeStep * (index+1)) The last element: [Response Time * index, MAX) 3) The number of calls in this response time duration. Example: [ [0, 0, 10], [0, 1, 43], ...] These ^^^ two represent the left bottom element, and another element above it.
axisYStep
Int!
getServiceTopN
[TopNEntity!]!
TopN is an aggregation query.
name
String!
Arg
topN
Int!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
order
Order!
Arg
name
String!
id
ID!
value
Long!
getAllServiceInstanceTopN
[TopNEntity!]!
name
String!
Arg
topN
Int!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
order
Order!
Arg
name
String!
id
ID!
value
Long!
getServiceInstanceTopN
[TopNEntity!]!
serviceId
ID!
Arg
name
String!
Arg
topN
Int!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
order
Order!
Arg
name
String!
id
ID!
value
Long!
getAllEndpointTopN
[TopNEntity!]!
name
String!
Arg
topN
Int!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
order
Order!
Arg
name
String!
id
ID!
value
Long!
getEndpointTopN
[TopNEntity!]!
serviceId
ID!
Arg
name
String!
Arg
topN
Int!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
order
Order!
Arg
name
String!
id
ID!
value
Long!
getTopNRecords
[TopNRecord!]!
condition
TopNRecordsCondition!
Arg
serviceId
ID!
Arg
metricName
String!
Arg
topN
Int!
Arg
order
Order!
Arg
Top N order, ASC or DES.
duration
Duration!
Arg
statement
String
latency
Long!
traceId
String
Have value, Only if the record has the trace id. Slow record
readMetricsValue
Long!
Since 9.5.0 `typeOfMetrics` and `listMetrics` are moved to metrics-v3. Metrics definition metadata query. Response the metrics type which determines the suitable query methods. typeOfMetrics(name: String!): MetricsType! Get the list of all available metrics in the current OAP server. Param, regex, could be used to filter the metrics by name. listMetrics(regex: String): [MetricDefinition!]! Read metrics single value in the duration of required metrics
condition
MetricsCondition!
Arg
name
String!
Arg
Metrics name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
entity
Entity!
Arg
Follow entity definition description.
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
readNullableMetricsValue
NullableValue!
Read metrics single value in the duration of required metrics NullableValue#isEmptyValue == true indicates no telemetry data rather than aggregated value is actually zero.
condition
MetricsCondition!
Arg
name
String!
Arg
Metrics name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
entity
Entity!
Arg
Follow entity definition description.
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
readMetricsValues
MetricsValues!
Read time-series values in the duration of required metrics
condition
MetricsCondition!
Arg
name
String!
Arg
Metrics name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
entity
Entity!
Arg
Follow entity definition description.
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
label
String
Could be null if no label assigned in the query condition
values
IntValues
Values of this label value.
values
[KVInt!]!
id
ID!
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
Since 9.5.0, isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
sortMetrics
[SelectedRecord!]!
Read entity list of required metrics and parent entity type.
condition
TopNCondition!
Arg
name
String!
Arg
Metrics name
parentService
String
Arg
Could be null if query the global top N.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
scope
Scope
Arg
Indicate the metrics entity scope. This is required in sortMetrics query. Only accept scope = Service/ServiceInstance/Endpoint, ignore others due to those are pointless.
topN
Int!
Arg
order
Order!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
name
String!
Literal string name for visualization
id
ID!
ID represents the owner of this entity.
value
String
Usually an integer value as this is metrics.
refId
ID
Have value, Only if the record has related trace id. UI should show this as an attached value.
readLabeledMetricsValues
[MetricsValues!]!
Read value in the given time duration, usually as a linear. labels: the labels you need to query.
condition
MetricsCondition!
Arg
name
String!
Arg
Metrics name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
entity
Entity!
Arg
Follow entity definition description.
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
labels
[String!]!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
label
String
Could be null if no label assigned in the query condition
values
IntValues
Values of this label value.
values
[KVInt!]!
id
ID!
value
Long!
This is the value, the caller must understand the Unit. Such as: 1. If ask for cpm metric, the unit and result should be count. 2. If ask for response time (p99 or avg), the unit should be millisecond.
isEmptyValue
Boolean!
Since 9.5.0, isEmptyValue indicates whether value == 0 represents actually zero(false, default) or no data(true).
readHeatMap
HeatMap
Heatmap is bucket based value statistic result.
condition
MetricsCondition!
Arg
name
String!
Arg
Metrics name, which should be defined in OAL script Such as: endpoint_resp_time = from(Endpoint.latency).avg() Then, `endpoint_resp_time`
entity
Entity!
Arg
Follow entity definition description.
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
values
[HeatMapColumn!]!
Each element of values matches the time point of the query duration. The element in the IntValues represents the value of the same index bucket
id
ID!
values
[Long!]!
buckets
[Bucket!]!
Bucket describes the ranges of #values represent.
min
String!
Usually the number represents the min value of this bucket, could be `infinite-` string as unbounded value
max
String!
Usually the number represents the max value of this bucket, could be `infinite+` string as unbounded value
readSampledRecords
[SelectedRecord!]!
Deprecated since 9.3.0, replaced by readRecords defined in record.graphqls Read the sampled records TopNCondition#scope is not required.
condition
TopNCondition!
Arg
name
String!
Arg
Metrics name
parentService
String
Arg
Could be null if query the global top N.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
scope
Scope
Arg
Indicate the metrics entity scope. This is required in sortMetrics query. Only accept scope = Service/ServiceInstance/Endpoint, ignore others due to those are pointless.
topN
Int!
Arg
order
Order!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
name
String!
Literal string name for visualization
id
ID!
ID represents the owner of this entity.
value
String
Usually an integer value as this is metrics.
refId
ID
Have value, Only if the record has related trace id. UI should show this as an attached value.
queryBasicTraces
TraceBrief
Search segment list with given conditions
condition
TraceQueryCondition
Arg
serviceId
ID
Arg
The value of 0 means all services.
serviceInstanceId
ID
Arg
traceId
String
Arg
endpointId
ID
Arg
queryDuration
Duration
Arg
The time range of traces started
start
String!
Arg
end
String!
Arg
step
Step!
Arg
minTraceDuration
Int
Arg
The min time of trace
maxTraceDuration
Int
Arg
The max time of trace
traceState
TraceState!
Arg
queryOrder
QueryOrder!
Arg
tags
[SpanTag!]
Arg
Map to the tags included in the traces
List arguments are not currently supported.
paging
Pagination!
Arg
pageNum
Int
Arg
pageNum starts in 1, the default is 1.
pageSize
Int!
Arg
traces
[BasicTrace!]!
segmentId
String!
endpointNames
[String!]!
duration
Int!
start
String!
isError
Boolean
traceIds
[String!]!
queryTrace
Trace
Read the specific trace ID with given trace ID
traceId
ID!
Arg
spans
[Span!]!
traceId
ID!
segmentId
ID!
spanId
Int!
parentSpanId
Int!
refs
[Ref!]!
traceId
ID!
parentSegmentId
ID!
parentSpanId
Int!
type
RefType!
Ref type represents why did the ref happen. Include: 1) CrossProcess 2) CrossThread
serviceCode
String!
serviceInstanceName
ID!
startTime
Long!
The start timestamp of the span in millisecond
endTime
Long!
The end timestamp of the span in millisecond
endpointName
String
type
String!
There are three span types: Local, Entry and Exit
peer
String
Peer network id, e.g. host+port, ip+port
component
String
The name of the tech stack component used for the execution represented by the span.
isError
Boolean
The error status is true when the execution returns error code or throws an exception(determined by the language).
layer
String
There are 5 layers: Unknown, Database, RPCFramework, Http, MQ and Cache
tags
[KeyValue!]!
key-value(string) pairs to specify unique attributes of ths span
key
String!
value
String
logs
[LogEntity!]!
The events happen of the span, especially in-process.
time
Long!
The timestamp of the log in millisecond
data
[KeyValue!]
key
String!
value
String
attachedEvents
[SpanAttachedEvent!]!
The attached events happen in the span's context but out-of-process. Check SpanAttachedEvent definition for more details.
startTime
Instant!
The nanosecond timestamp of the event's start time. Notice, most unit of timestamp in SkyWalking is milliseconds, but NANO-SECOND is required here. Because the attached event happens in the OS syscall level, most of them are executed rapidly.
seconds
Long!
The number of seconds from the epoch of 1970-01-01T00:00:00Z.
nanos
Int!
The number of nanoseconds, later along the time-line, from the seconds field. This is always positive, and never exceeds 999,999,999.
event
String!
The official event name. For example, the event name is a method signature from syscall stack.
endTime
Instant!
[Optional] The nanosecond timestamp of the event's end time.
seconds
Long!
The number of seconds from the epoch of 1970-01-01T00:00:00Z.
nanos
Int!
The number of nanoseconds, later along the time-line, from the seconds field. This is always positive, and never exceeds 999,999,999.
tags
[KeyValue]!
The tags for this event includes some extra OS level information, such as 1. net_device used for this exit span. 2. network L7 protocol
key
String!
value
String
summary
[KeyNumericValue!]!
The summary of statistics during this event. Each statistic provides a name(metric name) to represent the name, and an int64/long as the value.
key
String!
value
Long!
queryTraceTagAutocompleteKeys
[String!]
Read the list of searchable keys
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
queryTraceTagAutocompleteValues
[String!]
Search the available value options of the given key.
tagKey
String!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
getAlarmTrend
AlarmTrend!
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
numOfAlarm
[Int]!
getAlarm
Alarms
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
scope
Scope
Arg
keyword
String
Arg
paging
Pagination!
Arg
pageNum
Int
Arg
pageNum starts in 1, the default is 1.
pageSize
Int!
Arg
tags
[AlarmTag]
Arg
List arguments are not currently supported.
msgs
[AlarmMessage!]!
startTime
Long!
scope
Scope
id
ID!
message
String!
events
[Event!]!
uuid
String!
source
Source!
service
String
serviceInstance
String
endpoint
String
name
String!
type
EventType!
message
String
parameters
[KeyValue!]
key
String!
value
String
startTime
Long!
The start time (in milliseconds) of the event, measured between the current time and midnight, January 1, 1970 UTC. This field may be 0 if the user didn't report it or the `start` event is lost due to network issues.
endTime
Long
The end time (in milliseconds) of the event, measured between the current time and midnight, January 1, 1970 UTC. Empty or 0 if the event have not finished yet. This field may be 0 if the user didn't report it or the `end` event is lost due to network issues.
layer
String!
tags
[KeyValue!]!
key
String!
value
String
supportQueryLogsByKeywords
Boolean!
Return true if the current storage implementation supports fuzzy query for logs.
queryLogs
Logs
condition
LogQueryCondition
Arg
serviceId
ID
Arg
The value of 0 means all services.
serviceInstanceId
ID
Arg
endpointId
ID
Arg
relatedTrace
TraceScopeCondition
Arg
Related trace condition. When use related trace condition, duration is not required.
traceId
String!
Arg
segmentId
String
Arg
spanId
Int
Arg
queryDuration
Duration
Arg
The time range of log happened [Required] duration is required in most query, only exception is when use relatedTrace.
start
String!
Arg
end
String!
Arg
step
Step!
Arg
paging
Pagination!
Arg
pageNum
Int
Arg
pageNum starts in 1, the default is 1.
pageSize
Int!
Arg
tags
[LogTag!]
Arg
List arguments are not currently supported.
keywordsOfContent
[String!]
Arg
Fuzzy query conditions for the log content. Use these 2 keyword related condition, when supportQueryLogsByKeywords returns TRUE.
List arguments are not currently supported.
excludingKeywordsOfContent
[String!]
Arg
List arguments are not currently supported.
queryOrder
Order
Arg
Order by timestamp, default desc
errorReason
String
When this field is not empty, frontend should display it in UI
logs
[Log!]!
serviceName
String
serviceId
ID
serviceInstanceName
String
serviceInstanceId
ID
endpointName
String
endpointId
ID
traceId
String
timestamp
Long!
contentType
ContentType!
content
String
tags
[KeyValue!]
key
String!
value
String
test
LogTestResponse!
Test the logs and get the results of the LAL output.
requests
LogTestRequest!
Arg
log
String!
Arg
The log data of protocol https://github.com/apache/skywalking-data-collect-protocol/blob/e626ee04850703c220f64b642d2893fa65572943/logging/Logging.proto#41 in JSON format
dsl
String!
Arg
log
Log
The final log if it will be persisted, this can be empty if the log is dropped.
serviceName
String
serviceId
ID
serviceInstanceName
String
serviceInstanceId
ID
endpointName
String
endpointId
ID
traceId
String
timestamp
Long!
contentType
ContentType!
content
String
tags
[KeyValue!]
key
String!
value
String
metrics
[LogTestMetrics!]
The metrics generated during the LAL when testing a LogTestRequest
name
String!
tags
[KeyValue!]
key
String!
value
String
value
Long!
timestamp
Long!
queryLogTagAutocompleteKeys
[String!]
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
queryLogTagAutocompleteValues
[String!]
tagKey
String!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
getProfileTaskList
[ProfileTask!]!
query all task list, order by ProfileTask#startTime descending
serviceId
ID
Arg
endpointName
String
Arg
id
String!
serviceId
ID!
monitor service
serviceName
String!
endpointName
String!
endpoint name to monitored under the special service.
startTime
Long!
task start time (timestamp)
duration
Int!
duration of this task (minute)
minDurationThreshold
Int!
when the segment starts to execute, how long must it take before the monitor can be enbaled
dumpPeriod
Int!
when start monitor, time interval for each dumping the stack
maxSamplingCount
Int!
max number of traces will monitor on the sniffer
logs
[ProfileTaskLog!]!
instance operation logs
id
String!
instanceId
ID!
execute instance
instanceName
String!
operationType
ProfileTaskLogOperationType!
operation type
operationTime
Long!
operation time
getProfileTaskLogs
[ProfileTaskLog!]!
query all task logs
taskID
String
Arg
id
String!
instanceId
ID!
execute instance
instanceName
String!
operationType
ProfileTaskLogOperationType!
operation type
operationTime
Long!
operation time
getProfileTaskSegments
[ProfiledTraceSegments!]!
query all task profiled segment list
taskID
ID!
Arg
traceId
String!
instanceId
ID!
instanceName
String!
endpointNames
[String!]!
duration
Int!
start
String!
spans
[ProfiledSpan!]!
spanId
Int!
parentSpanId
Int!
segmentId
ID!
refs
[Ref!]!
traceId
ID!
parentSegmentId
ID!
parentSpanId
Int!
type
RefType!
Ref type represents why did the ref happen. Include: 1) CrossProcess 2) CrossThread
serviceCode
String!
serviceInstanceName
ID!
startTime
Long!
endTime
Long!
endpointName
String
type
String!
There are three span types: Local, Entry and Exit
peer
String
Peer network id, e.g. host+port, ip+port
component
String
isError
Boolean
layer
String
There are 5 layers: Unknown, Database, RPCFramework, Http, MQ and Cache
tags
[KeyValue!]!
key
String!
value
String
logs
[LogEntity!]!
time
Long!
The timestamp of the log in millisecond
data
[KeyValue!]
key
String!
value
String
profiled
Boolean!
Status represents profiling data that covers the duration of the span.
getSegmentsProfileAnalyze
ProfileAnalyzation!
analyze multiple profiled segments, start and end time use timestamp(millisecond)
queries
[SegmentProfileAnalyzeQuery!]!
Arg
segmentId
String!
Arg
timeRange
ProfileAnalyzeTimeRange!
Arg
start
Long!
Arg
end
Long!
Arg
tip
String
if not empty means backend has information gave to the user such as: a large number of snapshots, only analyze part of the data
trees
[ProfileStackTree!]!
thread stack dump analyze trees
elements
[ProfileStackElement!]!
id
ID!
work for tree building, id matches multiple parentId
parentId
ID!
codeSignature
String!
stack code signature
duration
Int!
Include the execution time of children(millisecond)
durationChildExcluded
Int!
Exclude the execution time of children(millisecond)
count
Int!
continuous dump count
getTemplate
DashboardConfiguration
Read an existing UI template according to given id.
id
String!
Arg
id
String!
ID is a generated UUID.
configuration
String!
JSON based configuration. The format of text is the export result on the UI page.
getAllTemplates
[DashboardConfiguration!]!
Read all configuration templatesã€‚
id
String!
ID is a generated UUID.
configuration
String!
JSON based configuration. The format of text is the export result on the UI page.
getMenuItems
[MenuItem!]!
Read all menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
title
String!
Title name
icon
String
Showing icon name
layer
String!
Linked layer name
activate
Boolean!
Activated menu should be listed on the menu, otherwise, it should stay in marketplace.
subItems
[MenuItem!]!
Sub menu items
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
description
String
Description of the item
documentLink
String
The document link for the latest version of this feature.
i18nKey
String
The i18n key for the title and description of this feature display in the UI.
queryBrowserErrorLogs
BrowserErrorLogs
condition
BrowserErrorLogQueryCondition
Arg
serviceId
ID
Arg
The value of 0 means all services.
serviceVersionId
ID
Arg
pagePathId
ID
Arg
category
ErrorCategory
Arg
queryDuration
Duration
Arg
The time range of browser perf data time
start
String!
Arg
end
String!
Arg
step
Step!
Arg
paging
Pagination!
Arg
pageNum
Int
Arg
pageNum starts in 1, the default is 1.
pageSize
Int!
Arg
logs
[BrowserErrorLog!]!
service
String!
serviceVersion
String!
time
Long!
pagePath
String!
category
ErrorCategory!
grade
String
message
String
line
Int
col
Int
stack
String
errorUrl
String
firstReportedError
Boolean!
queryEvents
Events
condition
EventQueryCondition
Arg
uuid
String
Arg
source
SourceInput
Arg
service
String
Arg
serviceInstance
String
Arg
endpoint
String
Arg
name
String
Arg
type
EventType
Arg
time
Duration
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
order
Order
Arg
layer
String
Arg
paging
Pagination!
Arg
pageNum
Int
Arg
pageNum starts in 1, the default is 1.
pageSize
Int!
Arg
events
[Event!]!
uuid
String!
source
Source!
service
String
serviceInstance
String
endpoint
String
name
String!
type
EventType!
message
String
parameters
[KeyValue!]
key
String!
value
String
startTime
Long!
The start time (in milliseconds) of the event, measured between the current time and midnight, January 1, 1970 UTC. This field may be 0 if the user didn't report it or the `start` event is lost due to network issues.
endTime
Long
The end time (in milliseconds) of the event, measured between the current time and midnight, January 1, 1970 UTC. Empty or 0 if the event have not finished yet. This field may be 0 if the user didn't report it or the `end` event is lost due to network issues.
layer
String!
listLayers
[String!]!
Read all available layers UI could use this list to determine available dashboards/panels The available layers would change with time in the runtime, because new service could be detected in any time. This list should be loaded periodically.
listServices
[Service!]!
Read the service list according to layer.
layer
String
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
getService
Service
Find service according to given ID. Return null if not existing.
serviceId
String!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
findService
Service
Search and find service according to given name. Return null if not existing.
serviceName
String!
Arg
id
ID!
Service ID = BASE64(name) + '.1' which keeps the most compatibility to 8.x data formats. All metrics of the service would refer to this ID. The layer ID would not be included in the service ID, as a service could have multidimensional monitoring, such as ALS + DP for the same service ----- Storage ----- Row ID in service_traffic entity includes layer ID. Service ID = BASE64(name) + '.' + Layer ID -------------------
name
String!
The unqiue name gloablly. Typically, name could be formated as `group::name` which would be recognized as a group and a short name.
group
String!
The custom/logic group of the service
shortName
String!
The unique name in the group. Mostly for visualization.
layers
[String!]!
Layer represents an abstract framework in the computer science, such as operation system(VM layer), Kubernetes(k8s layer), Service Mesh(typical Istio+Envoy layer). The name of layer is a string, but we would reserve the following for visualization(UI) https://github.com/apache/skywalking/blob/master/oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/Layer.java UI uses this literal layer names to provide various layout for their services with metrics. The layer collection is from the instances of this service. So, one service could have multiple layer due to instance-level registration.
normal
Boolean
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
listInstances
[ServiceInstance!]!
Read service instance list.
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
serviceId
ID!
Arg
id
ID!
name
String!
attributes
[Attribute!]!
name
String!
value
String!
language
Language!
instanceUUID
String!
getInstance
ServiceInstance
Search and find service instance according to given ID. Return null if not existing.
instanceId
String!
Arg
id
ID!
name
String!
attributes
[Attribute!]!
name
String!
value
String!
language
Language!
instanceUUID
String!
findEndpoint
[Endpoint!]!
Search and find matched endpoints according to given service and keyword(optional) If no keyword, randomly choose endpoint based on `limit` value.
keyword
String
Arg
serviceId
ID!
Arg
limit
Int!
Arg
id
ID!
name
String!
getEndpointInfo
EndpointInfo
endpointId
ID!
Arg
id
ID!
name
String!
serviceId
ID!
serviceName
String!
listProcesses
[Process!]!
Read process list.
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
instanceId
ID!
Arg
id
ID!
Process entity
name
String!
serviceId
ID!
serviceName
String!
instanceId
ID!
instanceName
String!
agentId
String!
Which agent report this process.
detectType
String!
The process found type.
attributes
[Attribute!]!
The process attributes, different process detect type have different corresponding attributes.
name
String!
value
String!
labels
[String!]!
The process labels.
getProcess
Process
Find process according to given ID. Return null if not existing.
processId
ID!
Arg
id
ID!
Process entity
name
String!
serviceId
ID!
serviceName
String!
instanceId
ID!
instanceName
String!
agentId
String!
Which agent report this process.
detectType
String!
The process found type.
attributes
[Attribute!]!
The process attributes, different process detect type have different corresponding attributes.
name
String!
value
String!
labels
[String!]!
The process labels.
estimateProcessScale
Long!
Get the number of matched processes through serviceId, labels Labels: the matched process should contain all labels The return is not a precise number, the process has its lifecycle, as it reboots and shutdowns with time. The return number just gives an abstract of the scale of profiling that would be applied.
serviceId
ID!
Arg
labels
[String!]!
Arg
getTimeInfo
TimeInfo
timezone
String
server current timezone, format: +0800
currentTimestamp
Long
server current timestamp, format: 1569124528392
queryPrepareCreateEBPFProfilingTaskData
EBPFProfilingTaskPrepare!
query eBPF profiling data for prepare create task
serviceId
ID!
Arg
couldProfiling
Boolean!
have enough process could profiling
processLabels
[String!]!
all process unique labels for filter
queryEBPFProfilingTasks
[EBPFProfilingTask!]!
query eBPF profiling task list query `triggerType == FIXED_TIME` when triggerType is absent
serviceId
ID
Arg
serviceInstanceId
ID
Arg
targets
[EBPFProfilingTargetType!]
Arg
List arguments are not currently supported.
triggerType
EBPFProfilingTriggerType
Arg
duration
Duration
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
taskId
ID!
profiling task ID
serviceId
ID!
service of profiling task
serviceName
String!
serviceInstanceId
ID
service instance of profiling task
serviceInstanceName
String
processLabels
[String!]!
process labels for filter
processId
ID
process of profiling task triggered by continuous profiling
processName
String
taskStartTime
Long!
Start time of the task, type is timestamp.
triggerType
EBPFProfilingTriggerType!
profiling task trigger type
fixedTriggerDuration
Long
task profiling duration
continuousProfilingCauses
[ContinuousProfilingTriggeredCause!]
"CONTINUOUS_PROFILING" type task causes
type
ContinuousProfilingMonitorType!
which type is reached the threshold all causes threshold and current value has multiply with "100" for avoid float value
singleValue
ContinuousProfilingSingleValueCause
single value based cause
threshold
Long!
defined threshold
current
Long!
current value of the process
uri
ContinuousProfilingURICause
uri based cause
uriRegex
String
which URI triggered threshold(one of)
uriPath
String
threshold
Long!
defined threshold
current
Long!
current value of the process URI
message
String!
summary message of cause, including type, value or uri
targetType
EBPFProfilingTargetType!
profiling task target type
createTime
Long!
the timestamp of creating this task
queryEBPFProfilingSchedules
[EBPFProfilingSchedule!]!
query schedules from profiling task
taskId
ID!
Arg
scheduleId
ID!
profiling task schedule ID
taskId
ID!
profiling task ID
process
Process!
process entity
id
ID!
Process entity
name
String!
serviceId
ID!
serviceName
String!
instanceId
ID!
instanceName
String!
agentId
String!
Which agent report this process.
detectType
String!
The process found type.
attributes
[Attribute!]!
The process attributes, different process detect type have different corresponding attributes.
name
String!
value
String!
labels
[String!]!
The process labels.
startTime
Long!
profiling schedule start timestamp(ms)
endTime
Long!
profiling schedule finished timestamp(ms)
analysisEBPFProfilingResult
EBPFProfilingAnalyzation!
analyze the profiling schedule aggregateType is "EBPFProfilingAnalyzeAggregateType#COUNT" as default.
scheduleIdList
[ID!]!
Arg
timeRanges
[EBPFProfilingAnalyzeTimeRange!]!
Arg
start
Long!
Arg
start timestamp(ms)
end
Long!
Arg
end timestamp(ms)
aggregateType
EBPFProfilingAnalyzeAggregateType
Arg
tip
String
if not empty means backend has information gave to the user
trees
[EBPFProfilingTree!]!
profiling analyzed trees
elements
[EBPFProfilingStackElement!]!
profiling stack elements
id
String!
the element ID
parentId
String!
the parent element ID
symbol
String!
stack element symbol name
stackType
EBPFProfilingStackType!
stack element type
dumpCount
Long!
current stack element total dump count
queryContinuousProfilingServiceTargets
[ContinuousProfilingPolicyTarget!]!
query all continuous profiling task through service
serviceId
ID!
Arg
type
ContinuousProfilingTargetType!
checkItems
[ContinuousProfilingPolicyItem!]!
type
ContinuousProfilingMonitorType!
threshold
String!
period
Int!
count
Int!
uriList
[String!]
uriRegex
String
triggeredCount
Int!
lastTriggerTimestamp
Long
queryContinuousProfilingMonitoringInstances
[ContinuousProfilingMonitoringInstance!]!
query all continuous profiling monitoring instances through service and policy
serviceId
ID!
Arg
target
ContinuousProfilingTargetType!
Arg
id
ID!
name
String!
attributes
[Attribute!]!
name
String!
value
String!
triggeredCount
Int!
lastTriggerTimestamp
Long
processes
[ContinuousProfilingMonitoringProcess!]!
monitoring process list under the monitoring instance
id
ID!
name
String!
detectType
String!
labels
[String!]!
triggeredCount
Int!
lastTriggerTimestamp
Long
readRecords
[Record!]!
Query collected records with given metric name and parent entity conditions, and return in the requested order.
condition
RecordCondition!
Arg
name
String!
Arg
Metrics name The scope of this metric is required to match the scope of the parent entity.
parentEntity
Entity!
Arg
Follow entity definition description. The owner of the sampled records
scope
Scope
Arg
Deprecated from 9.4.0 Scope could be sensed automatically through given metric name.
serviceName
String
Arg
1. metrics Scope=Service, ServiceInstance and Endpoint, set necessary serviceName/serviceInstanceName/endpointName 2. metrics Scope=ServiceRelation, ServiceInstanceRelation, EndpointRelation and ProcessRelation serviceName/serviceInstanceName/endpointName/processName is/are the source(s) destServiceName/destServiceInstanceName/destEndpointName/destProcessName is/are destination(s) set necessary names of sources and destinations.
normal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
serviceInstanceName
String
Arg
endpointName
String
Arg
processName
String
Arg
destServiceName
String
Arg
destNormal
Boolean
Arg
Normal service is the service having installed agent or metrics reported directly. Unnormal service is conjectural service, usually detected by the agent.
destServiceInstanceName
String
Arg
destEndpointName
String
Arg
destProcessName
String
Arg
topN
Int!
Arg
order
Order!
Arg
duration
Duration!
Arg
start
String!
Arg
end
String!
Arg
step
Step!
Arg
name
String!
Literal string name for visualization
id
ID!
ID of this record
value
String
Usually an integer value as this is a metric to measure this entity ID.
refId
ID
Have value, Only if the record has related trace id. UI should show this as an attached value.
getServiceHierarchy
ServiceHierarchy!
Query the service hierarchy, based on the given service. Will recursively return all related layers services in the hierarchy.
serviceId
ID!
Arg
layer
String!
Arg
relations
[HierarchyServiceRelation!]!
upperService
HierarchyRelatedService!
id
ID!
The related service ID.
name
String!
The literal name of the #id.
layer
String!
The related service's Layer name.
normal
Boolean!
lowerService
HierarchyRelatedService!
id
ID!
The related service ID.
name
String!
The literal name of the #id.
layer
String!
The related service's Layer name.
normal
Boolean!
getInstanceHierarchy
InstanceHierarchy!
Query the instance hierarchy, based on the given instance. Will return all direct related layers instances in the hierarchy, no recursive.
instanceId
ID!
Arg
layer
String!
Arg
relations
[HierarchyInstanceRelation!]!
upperInstance
HierarchyRelatedInstance!
id
ID!
The related instance ID.
name
String!
The literal name of the #id. Instance Name.
serviceId
ID!
Service id
serviceName
String!
The literal name of the #serviceId.
layer
String!
The service's Layer name. Service could have multiple layers, this is the layer of the service that the instance belongs to.
normal
Boolean!
lowerInstance
HierarchyRelatedInstance!
id
ID!
The related instance ID.
name
String!
The literal name of the #id. Instance Name.
serviceId
ID!
Service id
serviceName
String!
The literal name of the #serviceId.
layer
String!
The service's Layer name. Service could have multiple layers, this is the layer of the service that the instance belongs to.
normal
Boolean!
listLayerLevels
[LayerLevel!]!
List layer hierarchy levels. The layer levels are defined in the `hierarchy-definition.yml`.
layer
String!
The layer name.
level
Int!
The layer level. The level of the upper service should greater than the level of the lower service.