https://vscode-256bafaa-c2d6-40f6-8780-9d932d316271.preview.emergentagent.com/

ba19ae80


Generative User Interfaces
Understand how Tambo creates dynamic, visual interfaces in response to conversation instead of returning text-only responses.

Copy Markdown
Open
Traditional user interfaces are predetermined by their creators based on assumptions about how users should interact with the software. Users navigate menus, fill forms, and click through screens that developers have pre-built. To see sales data, you must know where to find the dashboard, which filters to apply, and how to configure the view. The interface is fixed and you must adapt to it.

Generative user interfaces flip this model. Instead of navigating predetermined layouts, users describe what they want in natural language, and the appropriate interface is decided in real-time. When you ask "Show me sales data," a generative interface renders an actual interactive chart component, populated with your data. The interface adapts to users rather than requiring users to adapt to the interface.

How Tambo Approaches Generative UI
Use Your Own React Components
Rather than attempting to have AI generate new UI from scratch in responses, which introduces risk and unpredictability, Tambo's approach is to use React components you build and give it access to. You provide descriptions of when and how to use each component, and Tambo automatically uses the appropriate components when responding to users' messages to help them accomplish their goals.

Tambo supports generative UI through two fundamental approaches:

Generative Components - Tambo creates new component instances in response to user messages. When a user asks for information or functionality, Tambo selects an appropriate component, generates the data to populate it, and includes it in the response message. This creates visual responses that appear as part of the conversation.

Interactable Components - Tambo updates components that are already placed on screen. You position components in your interface, and Tambo can read their current state and modify them through conversation.

Both approaches can work together in the same application. A user might ask Tambo to create a new chart (generative), then later ask it to "update the filters on my dashboard" (interactable). This flexibility allows you to choose the right pattern for each use case.

Component Selection
When a user sends a message, Tambo analyzes the request registered components and tools. It considers the semantic meaning of the message, the conversation history, and the descriptions of available components. Based on this analysis, it determines whether any of the available components match the user's intent and whether it needs to fetch any additional data to populate them.

The matching process happens automatically. Tambo interprets natural language, maps it to component purposes, and makes selection decisions. A message about displaying data might match to a chart component. A request to edit information could map to a form.

Rendering Selected Components
When using generative components, Tambo includes the selected component in the response message. The component becomes part of the message history, creating a visual conversation thread where text and interactive elements coexist.

While generative components appear in response messages, you control where they're displayed. Components can be rendered in a traditional chat interface, but they can also be placed anywhere in your application, across your entire layout. This flexibility means you're not limited to chat-style UIs. You can build dashboards, forms, or any interface pattern while still benefiting from AI-driven component generation.

This rendering happens in real-time. Users see their requests transform into visual responses immediately as data to populate any chosen component is streamed in from Tambo.

Generative User Interfaces
Octo Icon
Generative Components
Understanding how Tambo creates components on-demand in response to user messages.

Copy Markdown
Open
Generative components are React components that Tambo creates and renders dynamically in response to user messages. Unlike Interactable components that you pre-place on the page, generative components are chosen and instantiated by Tambo based on the conversation context.

When you register a component with Tambo, you're giving Tambo the ability to decide when and how to render that component. Tambo analyzes the user's message, considers available components, and generates appropriate props to create a new instance of the component inline in the conversation.

Key characteristics:

Created on-demand: Tambo generates new component instances in response to messages
One-time rendering: Each message can produce a new component instance
AI-driven selection: Tambo chooses which component to use based on the conversation
Props generated by AI: Tambo generates the props values based on the user's request
How Generative Components Work
The lifecycle of a generative component follows this flow:

1. Registration
Components are registered with Tambo either statically (at app startup) or dynamically (at runtime). Registration provides Tambo with:

The React component to render
A name and description for identification
A Zod schema defining valid props

const components: TamboComponent[] = [
  {
    name: "DataChart",
    description: "Displays data as a chart",
    component: DataChart,
    propsSchema: z.object({
      data: z.array(
        z.object({
          label: z.string(),
          value: z.number(),
        }),
      ),
      type: z.enum(["bar", "line", "pie"]),
    }),
  },
];
2. Component Selection
When a user sends a message, Tambo analyzes the request and available registered components. It uses the component's name and description to determine if a component is appropriate for the user's intent.

Tambo considers:

The semantic meaning of the user's message
Component descriptions and names
The conversation context and history
Available tools and resources
3. Props Generation
Once Tambo selects a component, it generates props that match the component's schema. The Zod schema acts as both validation and guidance:

Required fields: Tambo must provide values for all non-optional fields
Optional fields: Tambo may omit optional fields (marked with .optional())
Type constraints: Enum values, number ranges, and string formats guide generation
Descriptions: z.describe() provides hints about expected formats or usage patterns

// Schema with descriptions helps Tambo generate better props
const DataChartProps = z.object({
  data: z.array(
    z.object({
      label: z.string().describe("Short label text, 1-3 words"),
      value: z.number().describe("Numeric value for the data point"),
    }),
  ),
  type: z
    .enum(["bar", "line", "pie"])
    .describe("Use bar for comparisons, line for trends, pie for proportions"),
});
4. Component Rendering
Tambo renders the selected component with generated props as part of the assistant's message. The component appears inline in the conversation thread, creating a visual response alongside any text. Components rendered in messages become part of the conversation history, allowing Tambo to reference them in future messages.

Generative vs. Interactable Components
Understanding when to use each type helps you design effective Tambo applications:

Aspect	Generative Components	Interactable Components
Placement	Created by Tambo in messages	Pre-placed by you in your UI
Lifecycle	New instance per message	Persistent, updates in place
Use Case	Charts, summaries, one-time displays	Shopping carts, forms, persistent state
Registration	Via TamboProvider or registerComponent()	Via withInteractable() HOC
Updates	New message = new component	Same component, updated props
Example scenarios:

Generative: User asks "Show me sales data as a chart" → Tambo creates a new DataChart component
Interactable: User has a shopping cart on the page → User asks "Add 3 more items" → Tambo updates the existing cart component's props
You can use both together: register a component as generative for on-demand creation, and also make it interactable for persistent instances.

Generative User Interfaces
Octo Icon
Interactable Components
Allow Tambo to update your pre-placed components

Copy Markdown
Open
When you want to place specific components on screen rather than letting Tambo choose which to show, but still want to allow your users to interact with them using natural language, use Tambo's Interactable components. Unlike generative components that Tambo creates on-demand when responding to messages, Interactable components are pre-placed by you while still allowing Tambo to modify their props when responding to users.

You place them, set their initial state, and users can interact with them directly like any other React component. Simultaneously, Tambo can observe their current props values and update them through natural language requests.

This creates a conversational interface where traditional UI manipulation and natural language interaction work together. A user might click and edit a note's title, then ask Tambo to "update the content of this note with today's meeting notes," both modifying the same component.

How Interactables Work
Interactables are normal React components that you build and then wrap with Tambo's withInteractable to give Tambo access to them.


import { withInteractable } from "@tambo-ai/react";
import { Note } from "./note";
import { NotePropsSchema } from "./note-schema";
export const InteractableNote = withInteractable(Note, {
  componentName: "Note",
  description:
    "A simple note component for recording ideas that can change title, content, and background color",
  propsSchema: NotePropsSchema,
});
When you wrap a component with withInteractable, Tambo creates an automatic bidirectional connection:

Automatic Context Sending: The current props of the component are visible to Tambo automatically.

Automatic Tool Registration: Update tools are automatically registered to allow Tambo to update the component's props when needed.

Place these wherever you normally would within the application to enable a traditional, statically-organized, user interface enhanced with AI capabilities.


Generative User Interfaces
Octo Icon
Component State
Pass component state to Tambo as context for following user messages.

Copy Markdown
Open
By default, React component state is private and invisible to Tambo. If a user types into a text field and then asks Tambo to "check the grammar of what I typed," Tambo won't know the current value.

Replace useState with useTamboComponentState to give Tambo visibility into your component's state. This does two things:

AI visibility - State is included in follow-up message context, so Tambo can respond to "edit what I typed" requests
Rehydration - State persists when re-rendering thread history

Tracking State with useTamboComponentState
Consider this simple React component that allows a user to update an emailBody field, and tracks whether the email has been sent:

Simple email component

export const EmailSender = () => {
  ...
  const [emailBody, setEmailBody] = useState("") // tracks the message being typed
  const [isSent, setIsSent] = useState(false) // tracks whether the 'send' button has been clicked
  ...
}
If Tambo renders this component and the user edits the emailBody field, Tambo will not know about the edit. A following user message like "Help me edit what I've typed so far" will not generate a relevant response.

To allow Tambo to see these state values, simply replace useState with useTamboComponentState, and pass a keyName for each value:

Email component with tambo state

import { useTamboComponentState } from "@tambo-ai/react";
export const EmailSender = () => {
  ...
  const [emailBody, setEmailBody] = useTamboComponentState("emailBody", "");
  const [isSent, setIsSent] = useTamboComponentState("isSent", false);
  ...
}
Now tambo will know the current values of emailBody and isSent.

State Rehydration
When using generative components, your component is rendered as part of a message in a thread. Tambo persists component state values remotely when using useTamboComponentState, so when the thread is reloaded later, the component is re-rendered with the persisted state values.

For example, if a user:

Asks Tambo to generate an email component
Types "Hello, let's schedule a meeting" into the email body
Closes the app and returns later
When they reopen the thread, the email component will be re-rendered with emailBody set to "Hello, let's schedule a meeting" - the state is automatically restored from the persisted thread data.

This rehydration happens automatically when using useTamboComponentState. The hook reads the persisted state value for the given keyName when the component first mounts, ensuring user edits and interactions are preserved across page reloads and thread navigation.

Updating editable state from props
Often when we have an editable state value, like the emailBody above, we want Tambo to be able to generate and stream in the initial value. If a user sends "Help me generate an email asking about a good time to meet," Tambo should be able to fill in the value with relevant text, and then the user should be able to edit it.

When using useState this can be done by adding a useEffect that updates the state value with prop value changes:

Simple email component

export const EmailSender = ({ initialEmailBody }: { initialEmailBody: string }) => {
  ...
  const [emailBody, setEmailBody] = useState("") // tracks the message being typed
  const [isSent, setIsSent] = useState(false) // tracks whether the 'send' button has been clicked
  useEffect(() => {
    setEmailBody(initialEmailBody)
  }, [initialEmailBody])
  ...
}
However, when using useTamboComponentState, this pattern will cause the initial prop value to overwrite the latest stored state value when re-rendering a previously generated component.

Instead, use the setFromProp parameter of useTamboComponentState to specify a prop value that should be used to set the initial state value:

Simple email component

export const EmailSender = ({ initialEmailBody }: { initialEmailBody: string }) => {
  ...
  const [emailBody, setEmailBody] = useTamboComponentState("emailBody", "", initialEmailBody) // tracks the message being typed, and sets initial value from the prop
  const [isSent, setIsSent] = useTamboComponentState("isSent", false) // tracks whether the 'send' button has been clicked
  ...
}



               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src                                                      
apollo  App.tsx  components  g.txt  hooks  index.css  lib  main.tsx  pages  store  types
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/apollo        
client.ts  queries
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/apollo/queries
metrics.ts  services.ts  topology.ts  traces.ts
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components    
charts  common  layout  tambo  traces  ui
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components/ui
accordion.tsx     badge.tsx       carousel.tsx     context-menu.tsx   hover-card.tsx  navigation-menu.tsx  resizable.tsx    sidebar.tsx   tabs.tsx          toggle.tsx
alert-dialog.tsx  breadcrumb.tsx  chart.tsx        dialog.tsx         input-otp.tsx   pagination.tsx       scroll-area.tsx  skeleton.tsx  textarea.tsx      tooltip.tsx
alert.tsx         button.tsx      checkbox.tsx     drawer.tsx         input.tsx       popover.tsx          select.tsx       slider.tsx    toaster.tsx
aspect-ratio.tsx  calendar.tsx    collapsible.tsx  dropdown-menu.tsx  label.tsx       progress.tsx         separator.tsx    switch.tsx    toast.tsx
avatar.tsx        card.tsx        command.tsx      form.tsx           menubar.tsx     radio-group.tsx      sheet.tsx        table.tsx     toggle-group.tsx
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components/common
CustomRangePicker.tsx  DurationSelector.tsx
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components/charts 
MetricChart.tsx
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components/layout
AppLayout.tsx
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components/tambo 
markdownComponents.tsx        message-suggestions.tsx         message.tsx                       thread-container.tsx  thread-history.tsx
message-generation-stage.tsx  message-thread-collapsible.tsx  scrollable-message-container.tsx  thread-content.tsx    tooltip.tsx
message-input.tsx             message-thread-full.tsx         ServiceMetricsCard.tsx            thread-dropdown.tsx
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  ls client/src/components/traces
TraceList.tsx
               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ankit119   main -  

               
 [~/Downloads/Asset-Watcher (2)/Asset-Watcher]
 ✘  ankit119   main -  

